"""
Audit Trail Models for Complete Transaction Transparency.

CONCEPTUAL HIERARCHY (see docs/architecture/TRANSACTION-HIERARCHY.md):

    LEVEL 1: STRATEGY (Estratégia)
    └── Trading algorithm that generates signals
        Example: "Reversal on Support", "Breakout Momentum"

    LEVEL 2: OPERATION (Operação)  
    └── Complete trade cycle from entry to exit
        Example: Open LONG → Manage → Close with profit/loss

    LEVEL 3: MOVEMENT (Movimentação) ← THIS IS WHAT WE AUDIT
    └── Atomic financial action that changes balances
        Examples:
        - SPOT_BUY: Buy in spot market
        - SPOT_SELL: Sell in spot market  
        - MARGIN_BUY: Buy in isolated margin
        - MARGIN_SELL: Sell in isolated margin
        - TRANSFER_SPOT_TO_ISOLATED: Move collateral to margin
        - TRANSFER_ISOLATED_TO_SPOT: Withdraw from margin
        - MARGIN_BORROW: Borrow funds for leverage
        - MARGIN_REPAY: Repay borrowed amount
        - STOP_LOSS_PLACED: Create stop-loss order
        - STOP_LOSS_TRIGGERED: Stop-loss executed
        - INTEREST_CHARGED: Hourly margin interest
        - TRADING_FEE: Commission on trade

KEY INSIGHT:
- Binance only knows about MOVEMENTS (Level 3)
- Robson adds meaning by grouping movements into OPERATIONS (Level 2)
- Operations are generated by STRATEGIES (Level 1)

This enables:
✅ Complete audit trail (every movement recorded)
✅ Performance analysis (P&L per operation, per strategy)
✅ Regulatory compliance (trace every dollar)
✅ User transparency (understand what happened and why)
"""

from django.db import models
from django.utils import timezone
from decimal import Decimal


class MovementCategory(models.TextChoices):
    """
    High-level categories of movements.
    Helps with filtering and reporting.
    """
    TRADING = "TRADING", "Trading (Buy/Sell)"
    TRANSFER = "TRANSFER", "Transfer (Between Accounts)"
    CREDIT = "CREDIT", "Credit (Borrow/Repay)"
    ORDER = "ORDER", "Order Lifecycle"
    FEE = "FEE", "Fees & Interest"
    RISK = "RISK", "Risk Events"


class AccountType(models.TextChoices):
    """
    Which account the movement affects.
    Critical for understanding where money is.
    """
    SPOT = "SPOT", "Spot Account"
    ISOLATED_MARGIN = "ISOLATED_MARGIN", "Isolated Margin Account"
    CROSS_MARGIN = "CROSS_MARGIN", "Cross Margin Account"
    FUTURES = "FUTURES", "Futures Account"


class TransactionType(models.TextChoices):
    """
    All possible movement types in Robson.
    
    CATEGORY A: TRADING (changes asset holdings)
    """
    # Spot trading
    SPOT_BUY = "SPOT_BUY", "Spot Buy"
    SPOT_SELL = "SPOT_SELL", "Spot Sell"
    
    # Margin trading
    MARGIN_BUY = "MARGIN_BUY", "Margin Buy"
    MARGIN_SELL = "MARGIN_SELL", "Margin Sell"
    
    """
    CATEGORY B: TRANSFERS (moves assets between accounts)
    """
    TRANSFER_SPOT_TO_ISOLATED = "TRANSFER_SPOT_TO_ISOLATED", "Transfer Spot → Isolated Margin"
    TRANSFER_ISOLATED_TO_SPOT = "TRANSFER_ISOLATED_TO_SPOT", "Transfer Isolated Margin → Spot"
    # Legacy names for backwards compatibility
    TRANSFER_TO_MARGIN = "TRANSFER_TO_MARGIN", "Transfer to Margin"
    TRANSFER_FROM_MARGIN = "TRANSFER_FROM_MARGIN", "Transfer from Margin"
    
    """
    CATEGORY C: CREDIT (creates or settles obligations)
    """
    MARGIN_BORROW = "MARGIN_BORROW", "Margin Borrow"
    MARGIN_REPAY = "MARGIN_REPAY", "Margin Repay"
    INTEREST_CHARGED = "INTEREST_CHARGED", "Interest Charged"
    
    """
    CATEGORY D: ORDER LIFECYCLE (order state changes)
    """
    STOP_LOSS_PLACED = "STOP_LOSS_PLACED", "Stop-Loss Placed"
    STOP_LOSS_TRIGGERED = "STOP_LOSS_TRIGGERED", "Stop-Loss Triggered"
    STOP_LOSS_CANCELLED = "STOP_LOSS_CANCELLED", "Stop-Loss Cancelled"
    TAKE_PROFIT_PLACED = "TAKE_PROFIT_PLACED", "Take-Profit Placed"
    TAKE_PROFIT_TRIGGERED = "TAKE_PROFIT_TRIGGERED", "Take-Profit Triggered"
    LIMIT_ORDER_PLACED = "LIMIT_ORDER_PLACED", "Limit Order Placed"
    LIMIT_ORDER_FILLED = "LIMIT_ORDER_FILLED", "Limit Order Filled"
    LIMIT_ORDER_CANCELLED = "LIMIT_ORDER_CANCELLED", "Limit Order Cancelled"
    
    """
    CATEGORY E: FEES
    """
    TRADING_FEE = "TRADING_FEE", "Trading Fee"
    FEE_PAID = "FEE_PAID", "Fee Paid"
    
    """
    CATEGORY F: RISK EVENTS
    """
    LIQUIDATION = "LIQUIDATION", "Liquidation"
    MARGIN_CALL = "MARGIN_CALL", "Margin Call Warning"


class TransactionStatus(models.TextChoices):
    """Transaction status."""
    PENDING = "PENDING", "Pending"
    FILLED = "FILLED", "Filled"
    PARTIALLY_FILLED = "PARTIALLY_FILLED", "Partially Filled"
    CANCELLED = "CANCELLED", "Cancelled"
    FAILED = "FAILED", "Failed"
    EXPIRED = "EXPIRED", "Expired"


class AuditTransaction(models.Model):
    """
    Unified audit trail for ALL transactions.
    
    Every operation that moves money or creates obligations is recorded here.
    This provides complete transparency for the user.
    """
    
    # Identifiers
    transaction_id = models.CharField(
        max_length=64,
        unique=True,
        db_index=True,
        help_text="Unique transaction ID (UUID or Binance ID)",
    )
    
    binance_order_id = models.CharField(
        max_length=64,
        null=True,
        blank=True,
        db_index=True,
        help_text="Binance order/transaction ID",
    )
    
    client = models.ForeignKey(
        'clients.Client',
        on_delete=models.PROTECT,
        related_name='audit_transactions',
        help_text="Client who owns this transaction",
    )
    
    # Transaction details
    transaction_type = models.CharField(
        max_length=30,
        choices=TransactionType.choices,
        db_index=True,
        help_text="Type of transaction",
    )
    
    status = models.CharField(
        max_length=20,
        choices=TransactionStatus.choices,
        default=TransactionStatus.PENDING,
        db_index=True,
        help_text="Transaction status",
    )
    
    symbol = models.CharField(
        max_length=20,
        db_index=True,
        help_text="Trading pair (e.g., BTCUSDC)",
    )
    
    asset = models.CharField(
        max_length=10,
        help_text="Asset involved (e.g., BTC, USDC)",
    )
    
    # Quantities
    quantity = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        help_text="Quantity of asset",
    )
    
    price = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="Price per unit",
    )
    
    total_value = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="Total value (quantity × price)",
    )
    
    fee = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal("0"),
        help_text="Transaction fee",
    )
    
    fee_asset = models.CharField(
        max_length=10,
        null=True,
        blank=True,
        help_text="Asset used for fee payment",
    )
    
    # Context
    side = models.CharField(
        max_length=10,
        null=True,
        blank=True,
        help_text="BUY or SELL",
    )
    
    leverage = models.PositiveSmallIntegerField(
        null=True,
        blank=True,
        help_text="Leverage used (for margin trades)",
    )
    
    is_isolated_margin = models.BooleanField(
        default=False,
        help_text="Whether this is an isolated margin transaction",
    )
    
    # Account type - WHERE did this happen?
    account_type = models.CharField(
        max_length=20,
        choices=AccountType.choices,
        default=AccountType.SPOT,
        db_index=True,
        help_text="Which account this movement affects (Spot, Isolated Margin, etc.)",
    )
    
    # Movement category for filtering/reporting
    category = models.CharField(
        max_length=20,
        choices=MovementCategory.choices,
        default=MovementCategory.TRADING,
        db_index=True,
        help_text="High-level category of this movement",
    )
    
    # ========================================
    # ROBSON ABSTRACTION LINKS
    # These connect atomic movements to higher-level concepts
    # ========================================
    
    # Link to Operation (Level 2)
    # One Operation has many Movements
    related_operation = models.ForeignKey(
        'api.Operation',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='movements',
        help_text="The Operation (trade cycle) this movement belongs to",
    )
    
    # Related records
    related_position = models.ForeignKey(
        'api.MarginPosition',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='movements',
        help_text="Related margin position",
    )
    
    related_order = models.ForeignKey(
        'api.Order',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='movements',
        help_text="Related order",
    )
    
    # Risk management
    stop_price = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="Stop-loss price (if applicable)",
    )
    
    risk_amount = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="Risk amount (if applicable)",
    )
    
    risk_percent = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="Risk as percentage of capital",
    )
    
    # Audit metadata
    description = models.TextField(
        help_text="Human-readable description of the transaction",
    )
    
    raw_response = models.JSONField(
        null=True,
        blank=True,
        help_text="Raw API response from Binance",
    )
    
    created_at = models.DateTimeField(
        auto_now_add=True,
        db_index=True,
        help_text="When this record was created",
    )
    
    executed_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When the transaction was executed on exchange",
    )
    
    source = models.CharField(
        max_length=50,
        default="robson",
        help_text="Source of transaction (robson, binance_sync, manual)",
    )
    
    class Meta:
        db_table = 'api_audit_transaction'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['client', 'created_at']),
            models.Index(fields=['transaction_type', 'created_at']),
            models.Index(fields=['symbol', 'created_at']),
            models.Index(fields=['status', 'created_at']),
            models.Index(fields=['account_type', 'created_at']),
            models.Index(fields=['category', 'created_at']),
            models.Index(fields=['related_operation', 'created_at']),
        ]
        verbose_name = "Audit Transaction (Movement)"
        verbose_name_plural = "Audit Transactions (Movements)"
    
    def __str__(self):
        account = f"[{self.account_type}]" if self.account_type else ""
        return f"{account} {self.transaction_type} {self.quantity} {self.asset} @ {self.price} ({self.status})"
    
    def save(self, *args, **kwargs):
        """Auto-determine category from transaction type if not set."""
        if not self.category or self.category == MovementCategory.TRADING:
            self.category = self._infer_category()
        if not self.account_type:
            self.account_type = self._infer_account_type()
        super().save(*args, **kwargs)
    
    def _infer_category(self) -> str:
        """Infer the movement category from transaction type."""
        tx_type = self.transaction_type
        
        # Trading
        if tx_type in [TransactionType.SPOT_BUY, TransactionType.SPOT_SELL,
                       TransactionType.MARGIN_BUY, TransactionType.MARGIN_SELL]:
            return MovementCategory.TRADING
        
        # Transfers
        if tx_type in [TransactionType.TRANSFER_SPOT_TO_ISOLATED,
                       TransactionType.TRANSFER_ISOLATED_TO_SPOT,
                       TransactionType.TRANSFER_TO_MARGIN,
                       TransactionType.TRANSFER_FROM_MARGIN]:
            return MovementCategory.TRANSFER
        
        # Credit
        if tx_type in [TransactionType.MARGIN_BORROW, TransactionType.MARGIN_REPAY,
                       TransactionType.INTEREST_CHARGED]:
            return MovementCategory.CREDIT
        
        # Order lifecycle
        if tx_type in [TransactionType.STOP_LOSS_PLACED, TransactionType.STOP_LOSS_TRIGGERED,
                       TransactionType.STOP_LOSS_CANCELLED, TransactionType.TAKE_PROFIT_PLACED,
                       TransactionType.TAKE_PROFIT_TRIGGERED, TransactionType.LIMIT_ORDER_PLACED,
                       TransactionType.LIMIT_ORDER_FILLED, TransactionType.LIMIT_ORDER_CANCELLED]:
            return MovementCategory.ORDER
        
        # Fees
        if tx_type in [TransactionType.TRADING_FEE, TransactionType.FEE_PAID]:
            return MovementCategory.FEE
        
        # Risk events
        if tx_type in [TransactionType.LIQUIDATION, TransactionType.MARGIN_CALL]:
            return MovementCategory.RISK
        
        return MovementCategory.TRADING  # Default
    
    def _infer_account_type(self) -> str:
        """Infer the account type from transaction type."""
        tx_type = self.transaction_type
        
        # Spot operations
        if tx_type in [TransactionType.SPOT_BUY, TransactionType.SPOT_SELL]:
            return AccountType.SPOT
        
        # Margin operations
        if tx_type in [TransactionType.MARGIN_BUY, TransactionType.MARGIN_SELL,
                       TransactionType.MARGIN_BORROW, TransactionType.MARGIN_REPAY]:
            return AccountType.ISOLATED_MARGIN if self.is_isolated_margin else AccountType.CROSS_MARGIN
        
        # Transfers - use the destination for transfers TO, source for transfers FROM
        if tx_type in [TransactionType.TRANSFER_SPOT_TO_ISOLATED, TransactionType.TRANSFER_TO_MARGIN]:
            return AccountType.ISOLATED_MARGIN  # Destination
        if tx_type in [TransactionType.TRANSFER_ISOLATED_TO_SPOT, TransactionType.TRANSFER_FROM_MARGIN]:
            return AccountType.SPOT  # Destination
        
        # Default to spot
        return AccountType.SPOT
    
    @property
    def is_buy(self) -> bool:
        return self.side == "BUY"
    
    @property
    def is_sell(self) -> bool:
        return self.side == "SELL"
    
    @property
    def is_margin(self) -> bool:
        return self.account_type in [AccountType.ISOLATED_MARGIN, AccountType.CROSS_MARGIN]
    
    @property
    def is_transfer(self) -> bool:
        return self.category == MovementCategory.TRANSFER
    
    @property
    def is_credit(self) -> bool:
        return self.category == MovementCategory.CREDIT


class BalanceSnapshot(models.Model):
    """
    Periodic snapshots of account balances for historical tracking.
    
    Helps reconstruct account state at any point in time.
    """
    
    client = models.ForeignKey(
        'clients.Client',
        on_delete=models.PROTECT,
        related_name='balance_snapshots',
    )
    
    snapshot_time = models.DateTimeField(
        db_index=True,
        help_text="When this snapshot was taken",
    )
    
    # Spot balances
    spot_usdc = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal("0"),
    )
    
    spot_btc = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal("0"),
    )
    
    # Margin balances
    margin_btc_free = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal("0"),
    )
    
    margin_btc_borrowed = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal("0"),
    )
    
    margin_usdc_free = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal("0"),
    )
    
    margin_usdc_borrowed = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        default=Decimal("0"),
    )
    
    # Calculated values
    btc_price = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        help_text="BTC price at snapshot time",
    )
    
    total_equity = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        help_text="Total equity in USDC",
    )
    
    margin_level = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="Margin level at snapshot",
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'api_balance_snapshot'
        ordering = ['-snapshot_time']
        indexes = [
            models.Index(fields=['client', 'snapshot_time']),
        ]
        verbose_name = "Balance Snapshot"
        verbose_name_plural = "Balance Snapshots"
    
    def __str__(self):
        return f"{self.client} @ {self.snapshot_time}: ${self.total_equity}"

